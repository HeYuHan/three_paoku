<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
            #world {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(#e4e0ba, #f7d9aa);
        }
        #control{
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            text-align:center;
        }
        button{
            margin-top: 100%;
            width: 20%;
            height: 50px;
        }
    </style>
</head>
<body>
    <div id="world"></div>
    <div id="control">
        <button style="margin-right:150px;" hover="Hover(0);">Left</button>
        <button >Right</button>
    </div>
    <script src="three.min.js"></script>
    <script src="./loaders/FBXLoader.js"></script>
    <script type="x-shader/x-vertex" id="uvoffsetvertex">
        uniform vec2 offsetUV;
        uniform vec2 scaleUV;
        uniform vec2 mapSize;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec2 offset = offsetUV;
            offset.x *= scaleUV.x/mapSize.x;
            offset.y *= scaleUV.y/mapSize.y;
            vUv.x *= scaleUV.x;
            vUv.y *= scaleUV.y;
            vUv += offset;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>
    <script type="x-shader/x-vertex" id="costomvertex">
        varying vec2 vUv;
        void main() {
            
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <script type="x-shader/x-fragment" id="costomfragment">
        varying vec2 vUv;
        uniform sampler2D ColorMap;
        void main() {
            gl_FragColor = texture2D(ColorMap,vUv);
            //gl_FragColor = vec4(1,1,0,1);
        }
    </script>
    <script>
        ///////////////////////////////////////////////////////////////////////////////////////////
        var ResourceCachedList={};
        function LoadModel(src,callback){
            var model=ResourceCachedList[src];
            if(model){
                callback(model);
            }
            else{
                var loader = new THREE.FBXLoader();
                loader.load(src, function ( object ) {
                    ResourceCachedList[src]=object;
                    callback(object);
                } );
            }

        }
        function LoadTexture(src){
            var tex=ResourceCachedList[src];
            if(tex)return tex;
            tex =  new THREE.TextureLoader().load(src);
            ResourceCachedList[src]=tex;
            tex.magFilter = THREE.LinearFilter; 
            tex.minFilter = THREE.LinearFilter; 
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        function CleanResourceCache(){
            ResourceCachedList=[];
        }
        ////////////////////////////////////////////////////////////////////////////////////////
        var PositionType={
            Left:0,
            Center:1,
            Right:2
        }
        var BuildingType={
            AD:0,
            Building:1
        }
        var ItemType={
            None:0,
            Gold:1,
            Car:2
        }
        var GameResConfig={
            m_Road:{
                m_Model:"res/models/road/dx_005.fbx",
                m_Texture:"res/texture/road/dx_001_min.png",
                m_Width:14,
                m_Height:5
            },
            m_Car:{
                m_Model:"res/models/car/player_car.fbx",
                m_Texture:"res/texture/car/player_car.png",
                m_Width:2,
                m_Height:4
            },
            m_EnemyCars:[
                "res/texture/car/car2.png"
            ],
            m_Items:[
                {
                    m_Type:ItemType.Gold,
                    m_Texture:"res/texture/item/gold.jpg"
                }
            ],
            m_Buildings:[
                {
                    m_Type:BuildingType.AD,
                    m_Position:PositionType.Left,
                    m_Texture:"res/texture/building/left_a.png",
                    m_Width:30,
                    m_Height:20
                },
                {
                    m_Type:BuildingType.AD,
                    m_Position:PositionType.Right,
                    m_Texture:"res/texture/building/right_a.png",
                    m_Width:30,
                    m_Height:20
                }
            ]
        }
        ///////////////////////////////////////////////////////////////////////////////////////
        var GameConfig={
            m_RoadLength:500,
            m_RoadWidth:14,
            m_ADDistance:50,
        }
        ///////////////////////////////////////////////////////////////////////////////////////////
         //item
        var ITME_LIST={
            time:1,
            data:[
                [ItemType.None,ItemType.Car,ItemType.None],
                [ItemType.Gold,ItemType.None,ItemType.Gold],
                [ItemType.Gold,ItemType.Car,ItemType.None],
                [ItemType.Car,ItemType.None,ItemType.Gold],
                [ItemType.Gold,ItemType.None,ItemType.Car]
            ]
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////
        var CacheType={
            Building:1,
            Item:2,
            Car:3,
        }

        var CACHED_OBJECT=[];






        var renderer, scene, camera;
        var HEIGHT, WIDTH;
        
       
        //run time data
        var palyer_car=null;
        var move_left=false;
        var move_right=false;
        var forword_speed=100;
        var forword_speed_offset=0;
        var right_left_speed=20;
        var road_material_arg=null;
        var road_material_uv_animation_time=0.0;
        var update_last_time=0;
        var left_ad_list=[];
        var item_list=[];
        var item_refresh_time=0;
        var item_refresh_index=0;
        
        
        function init(){
            HEIGHT = window.innerHeight;  
            WIDTH = window.innerWidth;
            camera = new THREE.PerspectiveCamera( 60, WIDTH / HEIGHT, 1, 10000 );
			camera.position.set(0,5,0);
            camera.rotation.set(-Math.PI*0.1,0,0);
            //camera.position.set(0,5,8);
			scene = new THREE.Scene();
			//scene.background = new THREE.Color( 0x050505 );
            renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: true ,
                precision: 'highp'
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(WIDTH, HEIGHT);
            var size= renderer.getSize();
            container = document.getElementById('world');
            container.appendChild(renderer.domElement);
        }

        function createRoad(){
            LoadModel(GameResConfig.m_Road.m_Model,model=>{
                var scale = GameConfig.m_RoadLength/GameResConfig.m_Road.m_Height;
                road_material_arg = {
                    mapSize:{value:new THREE.Vector2(1,GameResConfig.m_Road.m_Height)},
                    scaleUV:{value:new THREE.Vector2(1,scale)},
                    offsetUV:{value:new THREE.Vector2(0,0),type:'v2'},
                    ColorMap:{ value: LoadTexture(GameResConfig.m_Road.m_Texture)}
                };
                var shaderMaterial = new THREE.ShaderMaterial( {
                    uniforms: road_material_arg,
                    vertexShader:document.getElementById('uvoffsetvertex').textContent,
                    fragmentShader: document.getElementById('costomfragment').textContent
                });
                model.traverse(function (child) {
                    if (child.isMesh) {
                        child.material = shaderMaterial;
                    }
                });
                
                
                var group = new THREE.Object3D();
                group.add(model);
                scene.add(group);
                model.scale.set(1,1,scale);
                model.position.set(0,0,-GameConfig.m_RoadLength);
            });
        }
        function createCar(src,clone_mode){
            var mesh = new THREE.Object3D();
            mesh.position.set(0,0,-10);
            LoadModel(GameResConfig.m_Car.m_Model,model=>{
                if(clone_mode)model=model.clone();
                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        ColorMap: { value: LoadTexture(src) }
                    },
                    vertexShader: document.getElementById('costomvertex').textContent,
                    fragmentShader: document.getElementById('costomfragment').textContent
                });
                model.traverse(function (child) {
                    if (child.isMesh) {
                        if (child.name != "pPlane1") child.material = shaderMaterial;
                    }
                });
                mesh.add(model);
                model.rotation.set(0,-Math.PI,0);
                model.scale.set(0.01,0.01,0.01);
            });
            return mesh;
        }
        function createBuilding(building){
            var mesh = new THREE.Object3D();
            var geometry = new THREE.PlaneGeometry( building.m_Width, building.m_Height, 1,1 );
            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    ColorMap: { value: LoadTexture(building.m_Texture) }
                },
                vertexShader: document.getElementById('costomvertex').textContent,
                fragmentShader: document.getElementById('costomfragment').textContent,
                transparent: true
            });
            var model = new THREE.Mesh( geometry, shaderMaterial );
            mesh.add(model);
            if(building.m_Position == PositionType.Left){
                model.position.set(-building.m_Width*0.5,building.m_Height*0.5,0);
                mesh.position.set(-GameConfig.m_RoadWidth*0.5,-5,-60);
            }
            else if(building.m_Position == PositionType.Right){
                model.position.set(building.m_Width*0.5,building.m_Height*0.5,0);
                mesh.position.set(GameConfig.m_RoadWidth*0.5,-5,-60);
            }
            // var shaderMaterial = new THREE.ShaderMaterial( {
			// 	uniforms: {
            //         ColorMap:{ value: new THREE.TextureLoader().load( "texture/left/left_a.png" ) ,type:'t'}
            //     },
			// 	vertexShader:document.getElementById('costomvertex').textContent,
			// 	fragmentShader: document.getElementById('costomfragment').textContent,
            //     transparent:true
			// });
            // var texture0 = shaderMaterial.uniforms.ColorMap.value;
            // //texture0.generateMipmaps = false; 
            // texture0.magFilter = THREE.LinearFilter; 
            // texture0.minFilter = THREE.LinearFilter; 
            // var geometry = new THREE.PlaneGeometry( AD_WIDTH, AD_HEIGHT, 1,1 );
            // this.plane = new THREE.Mesh( geometry, shaderMaterial );
            // this.mesh = new THREE.Object3D();
            // this.plane.position.set(-AD_WIDTH*0.5,0,0);
            // this.plane.rotation.set(0,0,0);
            // this.mesh.position.set(-ROAD_WIDTH*0.5,0,-40);
            // this.mesh.add(this.plane);
            return mesh;
        }
        

        function getCarSpeed(){
            return forword_speed+forword_speed_offset;
        }
        function getCachedObject(cache_data){
            var temp = CACHED_OBJECT[cache_data.m_Res.m_Texture];
            if(temp&&temp.length>0)return temp.pop();
            if(cache_data.m_Type == CacheType.Building)return createBuilding(cache_data.m_Res);
            if(cache_data.m_Type == CacheType.Car)return createCar(cache_data.m_Res.m_Texture,true);
            return null;
        }
        function pushCachedObject(obj){
            obj.visible=false;
            scene.remove(obj);
            var temp = CACHED_OBJECT[obj.m_CachedTag.m_Res.m_Texture];
            if(!temp){
                temp=[];
                CACHED_OBJECT[obj.m_CachedTag.m_Res.m_Texture]=temp;
            }
            temp.push(obj);
        }
        function chekcRunEnd(obj){
            return obj.position.z > 10;
        }
        Math.lerp=function(a,b,t){
            return a+(b-a)*t;
        }
        function update(frame){
           
            //update car
            if(palyer_car){
                if(move_left)palyer_car.position.x -= right_left_speed*frame;
                if(move_right)palyer_car.position.x += right_left_speed*frame;
                palyer_car.position.x = THREE.Math.clamp(palyer_car.position.x,-GameConfig.m_RoadWidth/3,GameConfig.m_RoadWidth/3);
            }
            if(forword_speed_offset!=0){
                forword_speed_offset=Math.lerp(forword_speed_offset,0,0.1);
            }
            //update road uv
            if(road_material_arg){
                road_material_uv_animation_time += frame;
                var once_time = GameConfig.m_RoadLength / getCarSpeed();
                var d1 = Math.ceil(road_material_uv_animation_time / once_time);
                var d2 = road_material_uv_animation_time - d1*once_time;
                var uv_offset = d2/once_time;
                road_material_arg.offsetUV.value=new THREE.Vector2(0,-uv_offset);
                
            }
            
            //update left_ad
            var temp_left_ad_list=[];
            for(var i=0;i<left_ad_list.length;i++){
                var ad = left_ad_list[i];
                ad.position.z += frame * getCarSpeed();
                if(chekcRunEnd(ad)){
                   pushCachedObject(ad);
                }
                else {
                    temp_left_ad_list.push(ad);
                }
            }
            left_ad_list = temp_left_ad_list;
            //create new left ad
            var create_new_left_ad=left_ad_list.length==0;
            if(!create_new_left_ad){
                var ad = left_ad_list[left_ad_list.length-1];
                if((GameConfig.m_RoadLength + ad.position.z)>GameConfig.m_ADDistance){
                    create_new_left_ad =true;
                }
            }
            if(create_new_left_ad){
                var cache_data={
                    m_Res:GameResConfig.m_Buildings[0],
                    m_Type:CacheType.Building,
                    
                }
                var ad = getCachedObject(cache_data);
                ad.m_CachedTag=cache_data;
                ad.visible=true;
                left_ad_list.push(ad);
                ad.position.z=-GameConfig.m_RoadLength;
                scene.add(ad);
            }
            //update item
            var temp_item_list=[];
            for(var i=0;i<item_list.length;i++){
                var item = item_list[i];
                item.position.z += frame * forword_speed*1.2;
                if(chekcRunEnd(item)){
                   pushCachedObject(item);
                }
                else if(Math.abs(item.position.z-palyer_car.position.z)<0.5){
                    pushCachedObject(item);
                    //forword_speed_offset=-80;
                }
                else {
                    temp_item_list.push(item);
                }
            }
            item_list = temp_item_list;
            item_refresh_time += frame;
            if(item_refresh_time>(ITME_LIST.time/ITME_LIST.data.length)){
                item_refresh_time=0;
                var group=ITME_LIST.data[item_refresh_index];
                for(var i=0;i<group.length;i++){
                    var type=group[i];
                    if(type == ItemType.Car){
                        var cache_data={
                            m_Res:{m_Texture:GameResConfig.m_EnemyCars[0]},
                            m_Type:CacheType.Car,
                        
                        }
                        var car = getCachedObject(cache_data);
                        car.m_CachedTag=cache_data;
                        car.visible=true;
                        car.position.set((i-1)*GameConfig.m_RoadWidth/3,0,-GameConfig.m_RoadLength);
                        
                        car.type=ItemType.Car;
                        scene.add(car);
                        item_list.push(car);
                    }
                }
                item_refresh_index=(item_refresh_index+1)%ITME_LIST.data.length;
            }

        }
        function loop(time){
            update((time-update_last_time)*0.001);
            update_last_time=time;
            // 渲染场景
            renderer.render(scene, camera);
            // 重新调用 render() 函数
            requestAnimationFrame(loop);
        }
        function RigisterEvent(){
            document.addEventListener( 'keydown', onDocumentKeyDown );
			document.addEventListener( 'keyup', onDocumentKeyUp );
			document.addEventListener( 'mousedown', onDocumentMouseDown );
			document.addEventListener( 'mouseup', onDocumentMouseUp );
			document.addEventListener( 'mousemove', onDocumentMouseMove );

			document.addEventListener( 'touchstart', onDocumentTouchStart );
			document.addEventListener( 'touchend', onDocumentTouchEnd );
			document.addEventListener( 'touchmove', onDocumentTouchMove );
        }
        function onDocumentTouchStart(event){
            if(event.clientY>HEIGHT/2){
                if(event.clientX<WIDTH/2)move_left=true;
                else move_right=true;
            }
        }
        function onDocumentTouchEnd(event){
            move_left=false;
            move_right=false;
        }
        function onDocumentTouchMove(event){

        }
        function onDocumentMouseDown(event){
            console.log(event);
            if(event.clientY>HEIGHT/2){
                if(event.clientX<WIDTH/2)move_left=true;
                else move_right=true;
            }
        }
        function onDocumentMouseUp(event){
            //console.log(event);
            move_left=false;
            move_right=false;
        }
        function onDocumentMouseMove(event){
            //console.log(event);
        }
        function onDocumentKeyDown(event){
            if(event.key == 'a'){
                move_left=true;
            }
            else if(event.key == 'd'){
                move_right=true;
            }
        }
        function onDocumentKeyUp(event){
            if(event.key == 'a'){
                move_left=false;
            }
            else if(event.key == 'd'){
                move_right=false;
            }
        }
        init();
        
        RigisterEvent();
        loop(0);
        createRoad();
        palyer_car=createCar(GameResConfig.m_Car.m_Texture);
        scene.add(palyer_car);
        // var building = createBuilding(GameResConfig.m_Buildings[0]);
        // scene.add(building);
    </script>
</body>
</html>